#include <string.h>
#include <omnetpp.h>

#include <unordered_set>
#include <map>
#include <list>
#include <ctime>

#include "Utils.h"

using namespace omnetpp;
using namespace std;

class LoRaEndDevice : public cSimpleModule/*, public cListener*/ {
  private:
    // ============ CLASS CONSTANTS ==============
    // $o and $i suffix is used to identify the input/output part of a two way gate
    const char* LORA_GATE_BASENAME = "lorag";
    const char* LORA_GATE_IN       = "lorag$i";
    const char* LORA_GATE_OUT      = "lorag$o";
    // ============ CLASS CONSTANTS ==============

    // ============ CLASS VARIABLES ==============
    // Identifiers for OTAA
    uint8_t joinEUI[EUI_SIZE];
    uint8_t devEUI[EUI_SIZE];
    uint8_t networkId[NETWORK_ID_SIZE];

    // Root keys for OTAA
    uint8_t nwkKey[KEY_LORAWAN_SIZE];
    uint8_t appKey[KEY_LORAWAN_SIZE];

    // Network and Application session keys
    uint8_t nwkSKey[KEY_LORAWAN_SIZE];
    uint8_t appSKey[KEY_LORAWAN_SIZE];

    // Root key for common session key with gateways in the radio range
    uint8_t commonKey[KEY_LORAWAN_SIZE];

    // Session key exclusively shared with gateways in the radio range
    uint8_t commonSKey[KEY_LORAWAN_SIZE];

    // Root key for session key with the associated gateway
    uint8_t associationKey[KEY_LORAWAN_SIZE];

    // Session key exclusively shared with the associated gateway
    uint8_t associationSKey[KEY_LORAWAN_SIZE];


    // End device address received during OTAA
    uint8_t address[IPv4_ADDRESS_SIZE];

    // Frame counters (actually they are of 32 bits and
    // only the least-significant 16 bits are entered in the LoRa frame.
    // Simplify by directly using 16 bits counters)
    uint16_t fCntUp;
    uint16_t fCntDown;

    // Nonce generated by the end device (OTAA + coordination protocol session keys)
    unsigned nonceDev;


    // State to handle tx, rx1, rx2 windows
    uint8_t transmissionWindowState;

    // Type of the received message (in class A only a message can be received after a transmission)
    //uint8_t messageReceived;

    // In class A only a message can be received after a transmission
    bool messageReceived;

    // Stage of the end device (activation + gateway-device coordination protocol)
    uint8_t stage;

    // Number of times a message must be repeated to reduce frame loss rate
    uint8_t retransmissions;

    // Request ID of the protocol execution
    uint8_t requestId;

    // Level number of the protocol execution
    uint8_t levelNumber;
    //bool isPairingAccepted; // Is pairing accepted by the selected gateway?
    //bool isPairingVerified; // Is pairing verified by the network server?

    // If true continue the research after having received a NACK from the selected gateway
    bool searchNewGateway;

    // Address of the selected gateway to pair with
    std::array<uint8_t, IPv4_ADDRESS_SIZE> selectedGatewayAddress;

    // Location string of the data profile
    char locationString[LOCATION_STRING_LENGTH];
    uint8_t locationStringIndex;


    // Collect STATS messages sent by gateways in the current round indexed by the address
    // to resend only the ACK in case of a repetition and not process again the message
    //std::map<std::array<uint8_t, IPv4_ADDRESS_SIZE>, cMessage*> statsMessages;
    // (È UN PO' SPRECATA LA MAP PERCHÈ NON SERVE MEMORIZZARE IL MSG COME VALUE, BASTEREBBE UN SET)
    //std::unordered_set<std::array<uint8_t, IPv4_ADDRESS_SIZE>> statsMessages = {}; // DOVREI DEFINIRE UNA HASH FUNCTION
    std::set<std::array<uint8_t, IPv4_ADDRESS_SIZE>> statsMessages;

    // Collect gateways to be ACKed in the current round,
    // removing from the list gateways for which the ACK has been sent.
    // (with class A this can be just the last received STATS message, so the list has size 1)
    std::list<std::array<uint8_t, IPv4_ADDRESS_SIZE>> gateways2ACK;

    // Map indexed and sorted by score (in ascending order) and value the list of tuples:
    // - corresponding IP addresses having such score
    // - timestamp at which the message was received
    //std::map<int, std::list<std::tuple<std::array<uint8_t, IPv4_ADDRESS_SIZE>, std::array<uint8_t, 4>>>> sortedGateways;
    //std::map<int, std::list<std::tuple<std::array<uint8_t, IPv4_ADDRESS_SIZE>, std::time_t>>> sortedGateways;
    std::map<int, std::list<std::tuple<std::array<uint8_t, IPv4_ADDRESS_SIZE>, simtime_t>>> sortedGateways;


    // Timeouts to handle the transmission window states
    cMessage* eventTimeoutTX;
    cMessage* eventTimeoutRX1;
    cMessage* eventTimeoutRX2;

    // Last message sent by the end device
    cPacket* msgOut;

    // Last message expected arrival time (time on air)
    simtime_t msgOutArrivalTime;


    // For display strings during animation & statistics
    unsigned long messagesIn;
    unsigned long messagesOut;
    unsigned long messagesLost;
    unsigned long messagesRetransmitted;
    unsigned long interferencesCount;
    unsigned long interferencesPossibleCount;

    // Position of the device for creating communication channels only with gateways in the radio range
    unsigned posX;
    unsigned posY;


    // Variables for physical layer
    uint8_t spreadingFactor;
    // Map indexed by the spreading factor and values a list of tuples composed of:
    // - bandwidth
    // - transmission power
    std::map<float, std::vector<std::tuple<float, uint8_t>>> bandwidths;
    // Map indexed by the bandwidth and values the channel frequencies
    std::map<float, std::vector<float>> channelFrequencies;


    // Variables for handling interferences
    std::set<LoRaEndDevice*> neighborDevicesInterferences;
    std::set<cModule*> neighborGatewaysInterferences;

    // List composed of messages sent by neighbor end devices and corresponding expiration times (preamble and time on air)
    std::list<std::tuple<cPacket*, simtime_t, simtime_t>> neighborMessages;

    // Map for handling interferences indexed by the message and value a tuple composed of:
    // - the SINR resulting after applying external noise
    // - the probability that the message is dropped
    //std::map<cMessage*, std::tuple<int, float>> interferences;
    // Use the shared ID among a message and its copies instead of the pointer of the message
    // because the sensor sends in broadcast multiple duplicates
    //std::map<long, std::tuple<int, float>> interferences;
    // Replace SINR with sum of interferences and noise in mW
    std::map<long, std::tuple<double, float>> interferences;


    // Variables for handling duty cycle
    double dutyCycle;                 // %
    double dutyCycleUsed;             // s
    simtime_t dutyCycleStartInterval; // s

    cMessage* eventTimeoutDutyCycle;
    // ============ CLASS VARIABLES ==============

    // ============ CLASS FUNCTIONS ==============
    uint8_t getRSSI(unsigned senderPosX, unsigned senderPosY);
    bool isValidPort(uint8_t port);
    uint8_t isValidLoRaFrame(cMessage *msg, uint8_t* frameType, uint8_t* port, uint8_t* payload);
    void printError(uint8_t error);
    int calculateScoreStatsMessage(uint8_t* payload, int rssi);
    void analyzeStatsMessage(uint8_t* payload, int rssi, uint8_t* gatewayIpAddress, int* score);
    void insertGatewayInDecisionMap(
            int score,
            std::array<uint8_t, IPv4_ADDRESS_SIZE>& selectedGatewayAddress,
            //std::array<uint8_t, 4>& timestampBytes);
            //std::time_t timestampBytes);
            simtime_t timestampBytes);
    bool isPairingRequestAccepted(uint8_t* payload);
    //bool verifyPairing(cMessage* msg);
    uint8_t readSensor();
    void sendMessage(bool sendDuplicate);
    void resendMessage(uint8_t* keyMIC);
    void notifyNeighborDevices(cPacket* msg, simtime_t arrivalPreamble, simtime_t arrivalFrame);
    //void notifyNeighborGateways(cPacket* msgInterference, std::list<std::tuple<cPacket*, int, bool>>& msgsInterfered);
    void notifyNeighborGateways(
            cPacket* msgInterference, std::list<std::tuple<cPacket*, cModule*, bool>>& interferedMessages);
    void verifyTransmissionInterference(cPacket* msg);
    bool surviveMessageToLoRaInterference(cMessage* msg);
    // ============ CLASS FUNCTIONS ==============

    // ============ CLASS SIGNALS ==============
    // Class signals for statistic collection
    simsignal_t signalSent;
    simsignal_t signalReceived;
    simsignal_t signalLost;
    simsignal_t signalRetransmitted;
    simsignal_t signalSentCount;
    simsignal_t signalReceivedCount;
    simsignal_t signalLostCount;
    simsignal_t signalRetransmittedCount;

    simsignal_t signalInterference;
    simsignal_t signalInterferencePossible;
    simsignal_t signalInterferenceCount;
    simsignal_t signalInterferencePossibleCount;
    // ============ CLASS SIGNALS ==============

  protected:
    // The following redefined virtual function holds the algorithm
    virtual void initialize() override;
    virtual void handleMessage(cMessage *msg) override;
    virtual void refreshDisplay() const override;

  public:
    LoRaEndDevice();
    virtual ~LoRaEndDevice();

    //virtual void receiveSignal(cComponent* source, simsignal_t signalID, cObject* obj, cObject* details) override;
    //virtual void receiveSignal(cComponent* source, simsignal_t signalID, long l, cObject* details) override;

    unsigned getPosX();
    unsigned getPosY();
    //simsignal_t getSignalInterference();

    void addNeighborDevice(LoRaEndDevice* neighbor);
    void addNeighborGateway(LoRaGateway* neighbor);
    void receiveNotification(cPacket* msg, simtime_t arrivalPreamble, simtime_t arrivalFrame);

    //void handleInterference(cPacket* msgInterference, std::list<std::tuple<cPacket*, cModule*, bool>>& interferedMessages);
    void handleInterferenceDownlink(
            cPacket* msgInterference, cModule* interferer,
            std::list<std::tuple<cPacket*, cModule*, bool>>& interferedMessages);

};



